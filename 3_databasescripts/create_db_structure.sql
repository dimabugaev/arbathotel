create schema if not exists operate;

drop trigger if exists hotels_insert_trigger ON operate.hotels;
drop procedure if exists operate.hotel_insert_trigger_fnc;

drop trigger if exists hotels_update_trigger ON operate.hotels;
drop procedure if exists operate.hotel_update_trigger_fnc;


drop table if exists operate.report_strings;
drop table if exists operate.report_items_setings;
drop table if exists operate.report_items;
drop table if exists operate.employees;
drop table if exists operate.sources;
drop table if exists operate.hotels;


CREATE TABLE operate.hotels
(
	 id	int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	 hotel_name varchar NOT NULL
);


CREATE TABLE operate.sources
(
	 id	int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	 source_name varchar NOT null,
	 source_type int NOT null,
	 source_external_key varchar NOT null
);

CREATE TABLE operate.employees
(
	 id	int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	 last_name varchar NOT null,
	 first_name varchar NOT null,
	 name_in_db varchar NOT null
);

CREATE TABLE operate.report_items
(
	 id	int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	 item_name varchar NOT null,
	 hotel_id int,
	 empl_id int,
	 
	 CONSTRAINT fk_hotels_items FOREIGN KEY ( hotel_id ) REFERENCES operate.hotels ( id ),
	 CONSTRAINT fk_empl_items FOREIGN KEY ( empl_id ) REFERENCES operate.employees ( id )
);



CREATE TABLE operate.report_items_setings
(
	 source_id int NOT null,
	 report_item_id int NOT null,
	 view_permission boolean,
	 
	 

	 CONSTRAINT report_items_setings_pk PRIMARY KEY (source_id, report_item_id),
	 CONSTRAINT fk_sources_setings FOREIGN KEY ( source_id ) REFERENCES operate.sources ( id ),
	 CONSTRAINT fk_items_setings FOREIGN KEY ( report_item_id ) REFERENCES operate.report_items ( id )
);

-- triggers add SOURCES

CREATE OR REPLACE FUNCTION operate.source_insert_trigger_fnc()
  RETURNS trigger AS
$$
BEGIN
 INSERT INTO operate.report_items_setings ( source_id, report_item_id, view_permission)
	select 
		NEW.id as source_id,
		ri.id as report_item_id,
		true as view_permission
	from 
		operate.report_items ri;
RETURN NEW;
END;
$$
LANGUAGE 'plpgsql';


CREATE TRIGGER sources_insert_trigger
  AFTER INSERT
  ON operate.sources
  FOR EACH ROW
  EXECUTE PROCEDURE operate.source_insert_trigger_fnc();

-- triggers ITEMS
 
CREATE OR REPLACE FUNCTION operate.report_item_insert_trigger_fnc()
  RETURNS trigger AS
$$
BEGIN
 INSERT INTO operate.report_items_setings ( source_id, report_item_id, view_permission)
	select 
		so.id as source_id,
		NEW.id as report_item_id,
		true as view_permission
	from 
		operate.sources so;
RETURN NEW;
END;
$$
LANGUAGE 'plpgsql';


CREATE TRIGGER report_items_trigger
  AFTER INSERT
  ON operate.report_items
  FOR EACH ROW
  EXECUTE PROCEDURE operate.report_item_insert_trigger_fnc();
 
----------------------


CREATE TABLE operate.report_strings
(
	 id	int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	 source_id int NOT null,
	 report_item_id int,
	 created timestamp not null default current_timestamp,
	 applyed timestamp,
	 report_date date,
	 hotel_id int,
	 sum_income decimal(18,2),
	 sum_spend decimal(18,2),
	 string_comment varchar,
	 
	 CONSTRAINT fk_sources_reports FOREIGN KEY ( source_id ) REFERENCES operate.sources ( id ),
	 CONSTRAINT fk_items_reports FOREIGN KEY ( report_item_id ) REFERENCES operate.report_items ( id ),
	 CONSTRAINT fk_hotpls_reports FOREIGN KEY ( hotel_id ) REFERENCES operate.hotels ( id )
);

-- triggers add update HOTELS

CREATE OR REPLACE FUNCTION operate.hotel_insert_trigger_fnc()
  RETURNS trigger AS
$$
BEGIN
 INSERT INTO operate.report_items ( item_name, hotel_id )
VALUES(NEW.hotel_name,NEW.id);
RETURN NEW;
END;
$$
LANGUAGE 'plpgsql';


CREATE TRIGGER hotels_insert_trigger
  AFTER INSERT
  ON operate.hotels
  FOR EACH ROW
  EXECUTE PROCEDURE operate.hotel_insert_trigger_fnc();
 
 
CREATE OR REPLACE FUNCTION operate.hotel_update_trigger_fnc()
  RETURNS trigger AS
$$
BEGIN
 UPDATE operate.report_items 
 SET item_name = NEW.hotel_name
 WHERE hotel_id = NEW.id;
RETURN NEW;
END;
$$
LANGUAGE 'plpgsql';


CREATE TRIGGER hotels_update_trigger
  AFTER UPDATE
  ON operate.hotels
  FOR EACH row
  WHEN (OLD.* IS DISTINCT FROM NEW.*)
  EXECUTE PROCEDURE operate.hotel_update_trigger_fnc();
 
-- triggers add update EMPLOYEES 
 
CREATE OR REPLACE FUNCTION operate.employee_insert_trigger_fnc()
  RETURNS trigger AS
$$
BEGIN
 INSERT INTO operate.report_items ( item_name, empl_id )
VALUES(new.name_in_db, NEW.id);
RETURN NEW;
END;
$$
LANGUAGE 'plpgsql';


CREATE TRIGGER employees_insert_trigger
  AFTER INSERT
  ON operate.employees
  FOR EACH ROW
  EXECUTE PROCEDURE operate.employee_insert_trigger_fnc();
 
 
CREATE OR REPLACE FUNCTION operate.employee_update_trigger_fnc()
  RETURNS trigger AS
$$
BEGIN
 UPDATE operate.report_items 
 SET item_name = NEW.name_in_db
 WHERE empl_id = NEW.id;
RETURN NEW;
END;
$$
LANGUAGE 'plpgsql';


CREATE TRIGGER hotels_update_trigger
  AFTER UPDATE
  ON operate.employees
  FOR EACH row
  WHEN (OLD.* IS DISTINCT FROM NEW.*)
  EXECUTE PROCEDURE operate.employee_update_trigger_fnc();
